---
layout: post
title: "Being a Programming Language Hipster with Céu"
date: 2017-06-21
---

I did a little game project recently in a new language. You've probably never heard of it.

![Hipster doggo](http://s2.quickmeme.com/img/82/82af2fda9892b0029e8585a058272dc7451e25fedff6425e4da30695a52554de.jpg)

It's called [Céu](http://ceu-lang.org/)! The SDL bindings I used were added to the language super-recently. I wanted to try working in Céu as I've been learning (somewhat passively) about concurrency in Python, and making something in a language that is all about synchronous design and concurrency appealed to me. So it was an interesting and challenging experience to make a game in a couple days with these very young tools:

-no documentation

-not googleable

-bad error messages

On the plus side, there were twelve example programs that shipped with the SDL library. Those were what I referenced whenever I wanted to get something accomplished. Still, there were some really hard problems - getting a string variable that would be updated with the score turned out to be a huge problem. After trying to get it working for a few hours (!), I worked around the issue of having a text variable rendered to screen with a graphical score display.
Another plus was having someone to work with. [@Johnicholas](https://github.com/johnicholas) has used Céu before, and he was incredibly helpful when it came to language features that were new to me. Such as:

-a helper function
{% highlight c %}
{% end highlight %}

-a class

-trails of execution

Céu provides parallel compositions to allow multiple lines of execution, aka trails, to coexist and wait for multiple events:

a par/and stands for parallel and and rejoins after all trails in parallel terminate
a par/or stands for parallel or and rejoins after any of the trails in parallel terminates, aborting all others
a par stands for parallel and never rejoins

-error messages
Céu ensures at compile time that a trail never runs forever, and hence, that reaction chains always run to completion in bounded time.
The compiler detects and warns when trails can run in unbounded time: loops that do not await, the so called tight loops.
In the following examples, which all issue warnings at compile time, the loop bodies have at least one path that does not await:

One way to rewrite tight loops would be Ceu's ```await async (variable) do```

It was nice having someone to bumble through the project with.
